### Front-end
For testing, we are initially planning on testing the front-end and server code separately. Since we are using react, we can make tests for the React components we make and their functionality. We used create-react-app to bootstrap our client-side code, and it uses the ‘jest’ testing framework under the hood. Using the framework, we are planning on putting in small tests for making sure the components we make are behaving and render as proper. These tests are fairly quick, can be done pre-transpilation, and easily executable by Travis. Thus, at least for P1, we will have tests for our front-end components that will be run by Travis each commit.

### Back-end
For the server-side, we are planning on using the ‘jasmine’ testing framework, as it is most compatible with our database, CouchDB. These might need something more complicated than just the code, such as a test server and database instance that Travis would have to connect to in order to run the tests, but overall it should not be an issue to have tests for the back-end, as the testing library was designed to be integratable with Travis.

### End-to-end
For now, we are not planning on having any end-to-end tests that deploy the full application and test it. This is because the end-to-end tests we know of, regarding screenshot matching using browser based frameworks like puppeteer or Selenium, rely heavily on a stable environment to work properly. Since none of our local machines are similar and Travis has a separate environment entirely, it would be a heavy work-load making and ensuring the stability of end-to-end tests that might not be worth it. This might change in the future if we decide to containerize the applications, as the Docker containers are perfect environments for such tests.
